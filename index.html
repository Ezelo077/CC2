<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>VR Cube Game</title>
  <link rel="icon" href="data:;base64,=">  

  <!-- A-Frame + Environment + Physics (Physics-System v3.3.0) -->
  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/aframe-environment-component@1.3.1/dist/aframe-environment-component.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/aframe-physics-system@3.3.0/dist/aframe-physics-system.min.js"></script>
</head>
<body>
  <a-scene vr-mode-ui="enabled: true" physics="debug: false" renderer="physicallyCorrectLights: true">
    <a-entity id="rig" position="0 1.6 0" movement-controls kinematic-body>
      <a-entity camera look-controls wasd-controls>
        <a-cursor fuse="false" material="color:white;shader:flat" raycaster="objects: .spawned"></a-cursor>
        <a-entity position="0 0 -1.5">
          <a-plane id="progressBar" height="0.05" width="0.001" color="#00FF00" visible="false"></a-plane>
          <a-text id="scoreText" value="Punkte: 0" color="#000" align="right" anchor="right" width="2"></a-text>
        </a-entity>
      </a-entity>
    </a-entity>

    <a-entity environment="preset:forest"></a-entity>
    <a-light type="ambient" color="#445451"></a-light>
    <a-light type="point" intensity="2" position="2 4 4"></a-light>
  </a-scene>

  <div id="info-display"></div>

  <script>
    // 1) teleport-on-hover component mit Index-Schema
    AFRAME.registerComponent('teleport-on-hover', {
      schema: { index: { type: 'int' } },
      init: function () {
        const el = this.el;
        const idx = this.data.index;
        let teleportTimeout, fadeInterval, progressInterval;
        const progressBar = document.querySelector('#progressBar');

        function getRandomColorRGB() { return { r: Math.random()*255|0, g: Math.random()*255|0, b: Math.random()*255|0 }; }
        function rgbToString(c)     { return `rgb(${c.r}, ${c.g}, ${c.b})`; }
        function lighten(c, amt=10) { return { r: Math.min(255,c.r+amt), g: Math.min(255,c.g+amt), b: Math.min(255,c.b+amt) }; }
        function updateScore() {
          document.querySelector('#scoreText').setAttribute('value', `Punkte: ${score}`);
        }

        let color = getRandomColorRGB();
        el.setAttribute('material','color', rgbToString(color));

        el.addEventListener('mouseenter', () => {
          let prog = 0;
          progressBar.setAttribute('width', 0.001);
          progressBar.setAttribute('visible', true);
          progressInterval = setInterval(() => {
            prog += 0.05;
            progressBar.setAttribute('width', prog);
          }, 100);
          fadeInterval = setInterval(() => {
            color = lighten(color);
            el.setAttribute('material','color', rgbToString(color));
          }, 300);

          teleportTimeout = setTimeout(() => {
            clearInterval(progressInterval);
            clearInterval(fadeInterval);
            progressBar.setAttribute('visible', false);
            // Score erhöhen und Server benachrichtigen
            score++;
            updateScore();
            sendRequest('*collect-cube*', idx);
          }, 2000);
        });

        el.addEventListener('mouseleave', () => {
          clearTimeout(teleportTimeout);
          clearInterval(fadeInterval);
          clearInterval(progressInterval);
          progressBar.setAttribute('visible', false);
        });
      }
    });

    // 2) Spawn-Helpers mit Index für jeden Würfel
    const numCubes = 3;
    const minDistOthers = 3, minDistCam = 3;
    const camPos = { x:0, y:1.6, z:0 };
    function getRandomPosition(){ return { x:(Math.random()-0.5)*10, y:1+Math.random()*2, z:(Math.random()-0.5)*10 }; }
    function isFarEnough(p, arr){
      if (Math.hypot(p.x-camPos.x, p.y-camPos.y, p.z-camPos.z) < minDistCam) return false;
      return arr.every(o => Math.hypot(p.x-o.x, p.y-o.y, p.z-o.z) >= minDistOthers);
    }
    function spawnCubesAt(positions){
      const scene = document.querySelector('a-scene');
      document.querySelectorAll('a-box.spawned').forEach(el => el.remove());
      positions.forEach((pos, i) => {
        const box = document.createElement('a-box');
        box.classList.add('spawned');
        box.setAttribute('teleport-on-hover', `index: ${i}`);  // Index übergeben
        box.setAttribute('scale','0.3 0.3 0.3');
        box.setAttribute('position',`${pos.x} ${pos.y} ${pos.z}`);
        box.addEventListener('click', () => sendRequest('*collect-cube*', i)); // Fallback für Klick
        box.setAttribute('animation__mouseenter','property: scale; to: 0.33 0.33 0.33; dur:300; startEvents:mouseenter');
        box.setAttribute('animation__mouseleave','property: scale; to: 0.3 0.3 0.3; dur:300; startEvents:mouseleave');
        box.setAttribute('animation__hover',`property: position; dir:alternate; dur:2000; loop:true; to:${pos.x} ${pos.y+0.3} ${pos.z}; easing:easeInOutSine`);
        scene.appendChild(box);
      });
    }

    // 3) Master-Client WebSocket Logic bleibt unverändert
    const socket = new WebSocket('wss://nosch.uber.space/web-rooms/');
    let clientId = null, clientCount = 0, score = 0;
    let cubePositions = [], lastClientCount = 0;

    function sendRequest(...msg){ socket.send(JSON.stringify(msg)); }

    socket.addEventListener('open', () => {
      sendRequest('*enter-room*','hello-world');
      sendRequest('*subscribe-client-count*');
      sendRequest('*subscribe-client-enter-exit*');
      setInterval(() => socket.send(''),30000);
    });

    socket.addEventListener('message', evt => {
      const inc = JSON.parse(evt.data||'[]'), cmd = inc[0], data = inc[1];
      switch(cmd){
        case '*client-id*':
          clientId = data;
          document.getElementById('info-display').innerText = `#${clientId}/${clientCount}`;
          if (clientId === 1){
            cubePositions = [];
            for(let i=0;i<numCubes;i++){
              let p,tries=0;
              do{ p=getRandomPosition(); tries++; }
              while(!isFarEnough(p,cubePositions)&&tries<50);
              cubePositions.push(p);
            }
            spawnCubesAt(cubePositions);
            sendRequest('*spawn-cubes*', cubePositions);
          }
          break;
        case '*client-count*':
          clientCount = data;
          document.getElementById('info-display').innerText = `#${clientId}/${clientCount}`;
          if(clientId===1 && clientCount>lastClientCount){ sendRequest('*spawn-cubes*', cubePositions); }
          lastClientCount = clientCount;
          break;
        case '*client-enter*':
          const newId = data;
          if(clientId===1 && newId!==1){ sendRequest('*spawn-cubes*', cubePositions); }
          break;
        case '*spawn-cubes*':
          spawnCubesAt(data);
          break;
        case '*collect-cube*':
          const idx = data;
          if(clientId===1){
            let newP,tries=0;
            do{ newP=getRandomPosition(); tries++; }
            while(!isFarEnough(newP,cubePositions)&&tries<50);
            cubePositions[idx] = newP;
            sendRequest('*spawn-cubes*', cubePositions);
          }
          break;
      }
    });
  </script>
</body>
</html>
